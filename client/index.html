<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Hello OpenCV.js</title>

    <script async src="vendor/opencv.js" type="text/javascript"></script>
</head>

<body>
    <p id="status">OpenCV.js is loading...</p>

    <div>
        <video id="videoInput" width="1080" height="810" />
    </div>
    <div>
        <canvas id="canvasRender"></canvas>
    </div>
    <div>
        <button onclick="captureDocScan()">Capture Doc Scan</button>
        <canvas id="canvasDocScan" width="595" height="842"></canvas>
    </div>
    <script type="text/javascript">
        /** @type {HTMLVideoElement} */
        const videoInput = document.getElementById('videoInput');
        /** @type {HTMLCanvasElement} */
        const canvasRender = document.getElementById('canvasRender');
        /** @type {HTMLCanvasElement} */
        const canvasDocScan = document.getElementById('canvasDocScan');

        canvasRender.width = videoInput.width;
        canvasRender.height = videoInput.height;

        const FPS = 30;
        let matSrc, matDst, cvVideoCapture;
        let paperContour = null;

        navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
            videoInput.srcObject = stream;
            videoInput.onloadedmetadata = () => {
                videoInput.play();
            };
        });

        function captureDocScan() {
            if (paperContour === null) {
                console.error(
                    'No paper contour detected. Please adjust the camera angle or lighting.'
                )
                return;
            }

            const {
                topLeftCorner,
                topRightCorner,
                bottomLeftCorner,
                bottomRightCorner,
            } = this.getCornerPoints(paperContour);

            let warpedDst = new cv.Mat();

            let dsize = new cv.Size(canvasDocScan.width, canvasDocScan.height);
            let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                topLeftCorner.x,
                topLeftCorner.y,
                topRightCorner.x,
                topRightCorner.y,
                bottomLeftCorner.x,
                bottomLeftCorner.y,
                bottomRightCorner.x,
                bottomRightCorner.y,
            ]);

            let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                0,
                0,
                canvasDocScan.width,
                0,
                0,
                canvasDocScan.height,
                canvasDocScan.width,
                canvasDocScan.height,
            ]);

            let M = cv.getPerspectiveTransform(srcTri, dstTri);
            cv.warpPerspective(
                matSrc,
                warpedDst,
                M,
                dsize,
                cv.INTER_LINEAR,
                cv.BORDER_CONSTANT,
                new cv.Scalar()
            );

            cv.imshow(canvasDocScan, warpedDst);

            warpedDst.delete();
        }

        function distance(p1, p2) {
            return Math.hypot(p1.x - p2.x, p1.y - p2.y);
        }

        function getCornerPoints(contour) {
            let rect = cv.minAreaRect(contour);
            const center = rect.center;

            let topLeftCorner;
            let topLeftCornerDist = 0;

            let topRightCorner;
            let topRightCornerDist = 0;

            let bottomLeftCorner;
            let bottomLeftCornerDist = 0;

            let bottomRightCorner;
            let bottomRightCornerDist = 0;

            for (let i = 0; i < contour.data32S.length; i += 2) {
                const point = { x: contour.data32S[i], y: contour.data32S[i + 1] };
                const dist = distance(point, center);
                if (point.x < center.x && point.y < center.y) {
                    // top left
                    if (dist > topLeftCornerDist) {
                        topLeftCorner = point;
                        topLeftCornerDist = dist;
                    }
                } else if (point.x > center.x && point.y < center.y) {
                    // top right
                    if (dist > topRightCornerDist) {
                        topRightCorner = point;
                        topRightCornerDist = dist;
                    }
                } else if (point.x < center.x && point.y > center.y) {
                    // bottom left
                    if (dist > bottomLeftCornerDist) {
                        bottomLeftCorner = point;
                        bottomLeftCornerDist = dist;
                    }
                } else if (point.x > center.x && point.y > center.y) {
                    // bottom right
                    if (dist > bottomRightCornerDist) {
                        bottomRightCorner = point;
                        bottomRightCornerDist = dist;
                    }
                }
            }

            return {
                topLeftCorner,
                topRightCorner,
                bottomLeftCorner,
                bottomRightCorner,
            };
        }

        function initCvProcessing() {
            matSrc = new cv.Mat(videoInput.height, videoInput.width, cv.CV_8UC4);
            matDst = new cv.Mat(videoInput.height, videoInput.width, cv.CV_8UC1);

            cvVideoCapture = new cv.VideoCapture(videoInput);
            let streaming = true;

            setTimeout(processVideo, 0);

            function processVideo() {
                try {
                    let timeBegin = Date.now();

                    if (!streaming) {
                        // clean and stop.
                        matSrc.delete();
                        matDst.delete();
                        return;
                    }

                    // start processing
                    cvVideoCapture.read(matSrc);
                    matSrc.copyTo(matDst);

                    // adopted from https://pyimagesearch.com/2014/09/01/build-kick-ass-mobile-document-scanner-just-5-minutes/
                    // grayscale
                    cv.cvtColor(matDst, matDst, cv.COLOR_BGR2GRAY);
                    // gaussian blur
                    cv.GaussianBlur(matDst, matDst, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
                    // canny
                    cv.Canny(matDst, matDst, 75, 200, 3, false)

                    // find contours
                    let contours = new cv.MatVector();
                    let hierarchy = new cv.Mat();
                    cv.findContours(
                        matDst,
                        contours,
                        hierarchy,
                        cv.RETR_CCOMP,
                        cv.CHAIN_APPROX_SIMPLE
                    );

                    // sort by descending and slice top 5
                    const sortedMatContours = new cv.MatVector()
                    const sortedMatContourArr = []
                    for (let index = 0; index < contours.size(); index++) {
                        const matContour = contours.get(index);
                        sortedMatContourArr.push(matContour)
                    }
                    // sort descending
                    sortedMatContourArr.sort((a, b) => cv.contourArea(b) - cv.contourArea(a))
                    // slice top 5
                    const sortedMatContourCount = Math.min(1, sortedMatContourArr.length)
                    for (let index = 0; index < sortedMatContourCount; index++) {
                        const matContour = sortedMatContourArr[index];
                        sortedMatContours.push_back(matContour)
                    }

                    let contourPaperIdx = -1;

                    let approx = new cv.Mat()
                    for (let index = 0; index < sortedMatContours.size(); index++) {
                        const matContour = sortedMatContours.get(index);
                        let peri = cv.arcLength(matContour, true);

                        cv.approxPolyDP(matContour, approx, 0.02 * peri, true)

                        if (approx.rows == 4 && approx.cols == 1) {
                            contourPaperIdx = index;
                        }
                    }

                    // let maxArea = 0;
                    // for (let i = 0; i < sortedMatContours.size(); ++i) {
                    //     let contourArea = cv.contourArea(sortedMatContours.get(i));
                    //     if (contourArea > maxArea) {
                    //         maxArea = contourArea;
                    //         contourPaperIdx = i;
                    //     }
                    // }

                    if (contourPaperIdx !== -1) {
                        paperContour = sortedMatContours.get(contourPaperIdx);
                        const paperContourColor = new cv.Scalar(255, 255, 255);
                        const paperMatContour = new cv.MatVector();
                        paperMatContour.push_back(paperContour);
                        cv.drawContours(matSrc, paperMatContour, -1, paperContourColor, 2, cv.LINE_4);
                        paperMatContour.delete();
                    } else {
                        // paperContour = null;
                    }

                    // clean up
                    hierarchy.delete()
                    contours.delete();
                    approx.delete();

                    cv.imshow(canvasRender, matSrc);

                    // schedule the next one.
                    let timeDelay = 1000 / FPS - (Date.now() - timeBegin);
                    setTimeout(processVideo, timeDelay);
                } catch (error) {
                    console.error(error);
                }
            }
        }

        let Module = {
            // https://emscripten.org/docs/api_reference/module.html#Module.onRuntimeInitialized
            onRuntimeInitialized() {
                document.getElementById('status').innerHTML = 'OpenCV.js is ready.';

                initCvProcessing();
            }
        };
    </script>
</body>

</html>